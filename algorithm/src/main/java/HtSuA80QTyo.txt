The followingcontent is providedunder a CreativeCommons license.Your support will help MITOpenCourseWare continueto offer high qualityeducational resources for free.To make a donation orview additional materialsfrom hundreds of MIT courses,visit MIT OpenCourseWareat ocw.mit.edu.PROFESSOR: Hi.I'm Srini Devadas.I'm a professor of electricalengineering and computerscience.I'm going to be co-lecturing6.006-- Introductionto Algorithms-- this termwith professor Erik Domane.Eric, say hi.ERIK DOMANE: Hi.[LAUGHTER]PROFESSOR: And wehope you're goingto have a fun timein 6.006 learninga variety of algorithms.What I want to do today isspend literally a minute or soon administrativedetails, maybe even less.What I'd like todo is to tell youto go to the website that'slisted up there and read it.And you'll get allinformation youneed about what this classis about from a standpointof syllabus; what's expectedof you; the problem setschedule; the quiz schedule;and so on and so forth.I want to dive right in and tellyou about interesting things,like algorithms andcomplexity of algorithms.I want to spendsome time giving youan overview of thecourse content.And then we'regoing to dive rightin and look at aparticular problem of peakfinding-- both the onedimensional version and a twodimensional version-- andtalk about algorithms to solvethis peak finding problem--both varieties of it.And you'll findthat there's reallya difference betweenthese various algorithmsthat we'll look at interms of their complexity.And what I meanby that is you'regoing to have different runtimes of these algorithmsdepending on inputsize, based on howefficient these algorithms are.And a prerequisite forthis class is 6.042.And in 6.042 you learnedabout asymptotic complexity.And you'll see thatin this lecturewe'll analyze relativelysimple algorithms todayin terms of theirasymptotic complexity.And you'll be ableto compare and saythat this algorithm is fastenthis other one-- assumingthat you have largeinputs-- because it'sasymptotically less complex.So let's dive right inand talk about the class.So the one sentencesummary of this classis that this is aboutefficient proceduresfor solving problemson large inputs.And when I say largeinputs, I mean thingslike the US highwaysystem, a mapof all of the highwaysin the United States;the human genome, whichhas a billion lettersin its alphabet; a socialnetwork responding to Facebook,that I guess has 500million nodes or so.So these are large inputs.Now our definition of large hasreally changed with the times.And so really the 21stcentury definition of largeis, I guess, a trillion.Right?Back when I was your agelarge was like 1,000.[LAUGHTER]I guess I'm dating myself here.Back when Eric was yourage, it was a million.Right?[LAUGHTER]But what's happening reallythe world is moving faster,things are getting bigger.We have the capability ofcomputing on large inputs,but that doesn'tmean that efficiencyisn't of paramount concern.The fact of matter isthat you can, maybe,scan a billion elementsin a matter of seconds.But if you had an algorithmthat required cubic complexity,suddenly you're not talkingabout 10 raised to 9,you're talking about10 raised to 27.And even currentcomputers can't reallyhandle those kinds of numbers,so efficiency is a concern.And as inputs get larger, itbecomes more of a concern.All right?So we're concerned about----efficient procedures-- forsolving large scale problemsin this class.And we're concernedabout scalability,because-- just as,you know, 1,000was a big number acouple of decades ago,and now it's kind ofa small number-- it'squite possible that by thetime you guys are professorsteaching this classin some universitythat a trillion is goingto be a small number.And we're going to be talkingabout-- I don't know--10 raised to 18as being somethingthat we're concerned with froma standpoint of a common caseinput for an algorithm.So scalability is important.And we want to be able to trackhow our algorithms are goingto do as inputs getlarger and larger.You going to learn a bunchof different data structures.We'll call them classicdata structures,like binary searchtrees, hash tables-- thatare called dictionariesin Python-- and datastructures-- such as balancedbinary search trees-- thatare more efficient than justthe regular binary search trees.And these are alldata structuresthat were inventedmany decades ago.But they've stoodthe test of time,and they continue to be useful.We're going to augment thesedata structures in various waysto make them more efficientfor certain kinds of problems.And while you're not going to bedoing a whole lot of algorithmdesign in thisclass, you will bedoing some design and awhole lot of analysis.The class following thisone, 6.046 Designing Analysisof Algorithms, isa class that youshould take ifyou like this one.And you can do a whole lot moredesign of algorithms in 6.046.But you will look atclassic data structuresand classical algorithmsfor these data structures,including things like sortingand matching, and so on.And one of the nicethings about this classis that you'll be doing realimplementations of these datastructures andalgorithms in Python.And in particular areeach of the problemsets in this class aregoing to have both a theorypart to them, and aprogramming part to them.So hopefully it'llall tie together.The kinds of things we're goingto be talking about in lecturesand recitations are goingto be directly connectedto the theory partsof the problem sets.And you'll be programming thealgorithms that we talk aboutin lecture, or augmentingthem, running them.Figuring out whether they workwell on large inputs or not.So let me talk a littlebit about the modulesin this class andthe problem sets.And we hope thatthese problem setsare going to be fun for you.And by fun I don't mean easy.I mean challenging andworthwhile, so at the end of ityou feel like you'velearned something,and you had somefun along the way.All right?So content wise----we have eightmodules in the class.Each of which,roughly speaking, hasa problem setassociated with it.The first of these is whatwe call algorithmic thinking.And we'll kick startthat one today.We'll look at a particularproblem, as I mentioned,of peak finding.And as part ofthis, you're goingto have a problem set that'sgoing to go out today as well.And you'll find thatin this problem setsome of these algorithmsI talk about today willbe coded in Python and given to.A couple of them are goingto have bugs in them.You'll have to analyze thecomplexity of these algorithms;figure out which ones arecorrect and efficient;and write a prooffor one of them.All right?So that's sort of anexample problem set.And you can expect thatmost of the problem setsare going to followthat sort of template.All right.So you'll get abetter sense of thisby the end of theday today for sure.Or a concrete senseof this, because we'llbe done with lecture and you'llsee your first problem set.We're going to be doing amodule on sorting and trees.Sorting you now about,sorting a bunch of numbers.Imagine if you hada trillion numbersand you wanted to sort them.What kind of algorithmcould use for that?Trees are a wonderfuldata structure.There's different varieties, themost common being binary trees.And there's ways of doingall sorts of things,like scheduling, and sorting,using various kinds of trees,including binary trees.And we have a problem set onsimulating a logic networkusing a particular kind ofsorting algorithm in a datastructure.That is going to beyour second problem set.And more quickly, we're goingto have modules on hashing,where we do thingslike genome comparison.In past terms we compared ahuman genome to a rat genome,and discovered theywere pretty similar.99% similar, whichis kind of amazing.But again, these thingsare so large that youhave to have efficiencyin the comparison methodsthat you use.And you'll find that if youdon't get the complexity lowenough, you just won'tbe able to complete--your program won't be able tofinish running within the timethat your problem set is do.Right?Which is a bit of a problem.So that's something to keepin mind as you test your code.The fact is that you will getlarge inputs to run your code.And you want to keepcomplexity in mindas you're coding and thinkingabout the pseudocode,if you will, of youralgorithm itself.We will talk about numerics.A lot of the time we talkabout such large numbersthat 32 bits isn't enough.Or 64 bits isn't enough torepresent these numbers.These numbers havethousands of bits.A good example isRSA encryption,that is used inSSL, for example.And when you go-- usehttps on websites,RSA is used at the back end.And typically you workwith prime numbersthat are thousandsof bits long in RSA.So how do you handle that?How does Python handle that?How do you writealgorithms that candeal with what are calledinfinite precision numbers?So we have a module on numericsin the middle of the term thattalks about that.Graphs, really afundamental data structurein all of computer science.You might have heard of thefamous Rubik's cube assignmentfrom .What's the minimumnumber of movesnecessary to go from agiven starting configurationto the final end configuration,where all of the faces-- eachof the faces has uniform color?And that can be posedas a graph problem.We'll probably dothat one this term.In previous termswe've done other thingslike the 15 puzzle.And so some ofthese are tentative.We definitely know what thefirst problem set is like,but the rest of them are,at this moment, tentative.And to finish up shortest paths.Again in terms pastwe've asked youto write code using aparticular algorithm thatfinds the shortest pathfrom Caltech to MIT.This time we may do thingsa little bit differently.We were thinking maybe we'llgive you a street map of Bostonand go figure outif Paul Revere usedthe shortest path to getto where he was going,or things like that.We'll try and make it fun.Dynamic programming is animportant algorithm designtechnique that's usedin many, many problems.And it can be used to do avariety of things, includingimage compression.How do you compress an imageso the number of pixelsreduces, but it stilllooks like the imagethat you started out with,that had many more pixels?All right?So you could use dynamicprogramming for that.And finally, advanced topics,complexity theory, researchand algorithms.Hopefully by now-- bythis time in the course,you have been soldon algorithms.And most, if notall of you, wouldwant to pursue acarrier in algorithms.And we'll give you a senseof what else is there.We're just scratching thesurface in this class,and there's many, manyclasses that you can possiblytake if you want to continuein-- to learn about algorithms,or to pursue acareer in algorithms.All right?So that's thestory of the class,or the synopsis of the class.And I encourage you to go spenda few minutes on the website.In particular please read thecollaboration policy, and geta sense of what isexpected of you.What the rules are in termsof doing the problem sets.And the coursegrading break down,the grading policies are alllisted on the website as well.All right.OK.So let's get started.I want to talk abouta specific problem.And talk about algorithmsfor a specific problem.We picked this problem, becauseit's so easy to understand.And they're fairlystraightforward algorithmsthat are not particularlyefficient to solvethis problem.And so this is a, kindof, a toy problem.But like a lot oftoy problems, it'svery evocative in that itpoints out the issues involvedin designingefficient algorithms.So we'll start witha one dimensionalversion of what wecall peak finding.And a peak finder is somethingin the one dimensional case.Runs on an array of numbers.And I'm just putting----symbols for each ofthese numbers here.And the numbers arepositive, negative.We'll just assumethey're all positive,it doesn't really matter.The algorithms wedescribe will work.And so we have thisone dimensional arraythat has ninedifferent positions.And a through i are numbers.And we want to find a peak.And so we have to definewhat we mean by a peak.And so, in particular,as an example,position 2 is apeak if, and onlyif, b greater than or equal toa, and b greater than or equalto c.So it's really a very localproperty correspondingto a peak.In the one dimensionalcase, it's trivial.Look to your left.Look to your right.If you are equal or greaterthan both of the elementsthat you see on the left andthe right, you're a peak.OK?And in the case ofthe edges, you onlyhave to look to one side.So position 9 is a peak if igreater than or equal to h.So you just have tolook to your left there,because you're all the wayon the right hand side.All right?So that's it.And the statement of theproblem, the one dimensionalversion, is find thepeak if it exists.All right?That's all there is to it.I'm going to give you astraightforward algorithm.And then we'll seeif we can improve it.All right?You can imagine that thestraightforward algorithm issomething that just, youknow, walks across the array.But we need that as a startingpoint for building somethingmore sophisticated.So let's say we startfrom left and allwe have is onetraversal, really.So let's say we have1, 2, and then wehave n over 2 overhere correspondingto the middle ofthis n element array.And then we haven minus 1, and n.What I'm interestedin doing is, not onlycoming up with astraightforward algorithm,but also preciselycharacterizingwhat its complexityis in relationto n, which is thenumber of inputs.Yeah?Question?AUDIENCE: Why doyou say if it existswhen the criteriain the [INAUDIBLE]guarantees [INAUDIBLE]?PROFESSOR: That's exactly right.I was going to get to that.So if you look at thedefinition of the peak,then what I have here isgreater than or equal to.OK?And so this-- That's a greatquestion that was asked.Why is there "if itexists" in this problem?Now in the case where I havegreater than or equal to,then-- this is a homeworkquestion for you,and for the rest of you-- arguethat any array will alwayshave a peak.OK?Now if you didn't have thegreater than or equal to,and you had a greater than,then can you make that argument?No, you can't.Right?So great question.In this case it'sjust a question--You would want tomodify this problemstatement to find the peak.But if I had a differentdefinition of a peak-- and thisis part of algorithmic thinking.You want to be able to createalgorithms that are general,so if the problemdefinition changes on you,you still have a startingpoint to go attackthe second versionof the problem.OK?So you could eliminatethis in the caseof the greater than orequal to definition.The "if it exists", becausea peak will always exist.But you probably wantto argue that whenyou want to show thecorrectness of your algorithm.And if in fact you hada different definition,well you would have to createan algorithm that tells youfor sure that a peakdoesn't exist, or finda peak if it exists.All right?So that's reallythe general case.Many a time it's possible thatyou're asked to do something,and you can't actually givean answer to the question,or find something that satisfiesall the constraints required.And in that case, you want tobe able to put up your handand say, you know what?I searched long and hard.I searched exhaustively.Here's my argument thatI searched exhaustively,and I couldn't find it.Right?If you do that, youget to keep your job.Right?Otherwise there'salways the casethat you didn'tsearch hard enough.So it's nice tohave that argument.All right?Great.Thanks for the question.Feel free to interrupt.Raise your hand, andI'm watching you guys,and I'm happy to answerquestions at any time.So let's talk about thestraightforward algorithm.The straightforwardalgorithm is somethingthat starts from the leftand just walks across.And you might have somethingthat looks like that.All right?By that-- By this I meanthe numbers are increasingas you start from theleft, the peak is somewherein the middle, and thenthings start decreasing.Right?So in this case, you know,this might be the peak.You also may havea situation wherethe peak is all theway on the right,you started from the left.And it's 1, 2, 3,4, 5, 6, literallyin terms of the numbers.And you're going to look atn elements going all the wayto the right in orderto find the peak.So in the case ofthe middle you'dlook at n over 2 elements.If it was right in the middle.And the complexity,worst case complexity----is what we call theta n.And it's theta n, becausein the worst case,you may have to lookat all n elements.And that would be the casewhere you started from the leftand you had to go allthe way to the right.Now remember theta n isessentially somethingthat's says of the order of n.So it gives you both the lowerbound and an upper bound.Big [? O ?] of n isjust upper bound.And what we'resaying here is, we'resaying this algorithmthat starts from the leftis going to, essentially,require in the worst casesomething that's aconstant times n.OK?And you know thatconstant could be 1.You could certainlyset things up that way.Or if you had a differentkind of algorithm,maybe you could workon the constant.But bottom line, we're onlyconcerned, at this moment,about as asymptotic complexity.And the asymptotic complexityof this algorithm is linear.All right?That make sense?OK.So someone help me do better.How can we do better?How can we lower theasymptotic complexityof a one dimensionalpeak finder?Anybody want totake a stab at that?Yeah?Back there.AUDIENCE: Do abinary search subset.You look at themiddle, and whateveris higher-- whichever side ishigher, then cut that in half,because you know there's a peak.PROFESSOR: On--AUDIENCE: For exampleif you're in the middleon the right side--there's a higher numberon the right side--then you would justlook at that, because you knowthat your peak's somewherein there.And you continuecutting in half.PROFESSOR: Excellent!Excellent!That's exactly right.So you can-- You can dosomething different, whichis essentially try andbreak up this problem.Use a divide and conquerstrategy, and recursively breakup this one dimensionalarray into smaller arrays.And try and get thiscomplexity down.Yeah?AUDIENCE: Are we assumingthat there's only one peak?PROFESSOR: No, we're not.AUDIENCE: OK.PROFESSOR: It's finda peak if it exists.And in this caseit's, "find a peak",because of the definition.We don't really needthis as it was discussed.All right?OK.So--So that was a great answer,and-- You know this classafter while isgoing to get boring.Right?Every class gets boring.So we, you know, try andbreak the monotony here a bit.And so-- And then the otherthing that we realizedwas that these seatsyou're sitting on-- thisis a nice classroom-- butthe seats you're sitting onare kind of hard.Right?So what Eric and Idid was we decidedwe'll help you guysout, especially the oneswho are-- who areinteracting with us.And we have these--[LAUGHTER]--cushions thatare 6.006 cushions.And, you know, that's a 2by 2 by 2 Rubik's cube here.And since you answered the firstquestion, you get a cushion.This is kind of like aFrisbee, but not really.So--[LAUGHTER]I'm not sure-- I'm not sureI'm going to get it to you.But the otherthing I want to sayis this is not a baseball game.Right?Where you just grab theball as it comes by.This is meant for him, myfriend in the red shirt.So here you go.Ah, too bad.All right.It is soft.So, you know, it won't-- itwon't hurt you if hits you.[LAUGHTER]All right.So we got a bunch of these.And raise your hands,you know, goingto ask-- There's goingto be-- I think-- There'ssome trivial questions thatwe're going to ask justto make sure you're awake.So an answer to thatdoesn't get you a cushion.But an answer like--What's your name?AUDIENCE: Chase.PROFESSOR: Chase.An answer likeChase just gave is--that's a good answer toa nontrivial question.That gets you a cushion.OK?All right, great.So let's put up byChase's algorithm up here.I'm going to write itout for the 1D version.So what we have here isa recursive algorithm.So the picture you wantto keep in your headis this picturethat I put up there.And this is a divideand conquer algorithm.You're going to see this overand over-- this paradigm--over and over in 6.006.We're going to look atthe n over 2 position.And we're going tolook to the left,and we're going tolook to the right.And we're going todo that in sequence.So----if a n over 2 is less thana n over 2 minus 1, then----only look at the left half.1 through n over 2 minus 1 tolook for peak-- for a peak.All right?So that's step one.And you know I couldput it on the right handside or the left hand side,doesn't really matter.I chose to do the left handside first, the left half.And so what I've done is,through that one step,if in fact you have thatcondition-- a n over 2is less than a n over 2 minus1-- then you move to your leftand you work on onehalf of the problem.But if that's not the case,then if n over-- n over 2is less than a over nover-- n by 2 plus 1,then only look at n over 2plus 1 through n for a peak.So I haven't botheredwriting out all the words.They're exactly the sameas the left hand side.You just look tothe right hand side.Otherwise if both of theseconditions don't fire,you're actually done.OK?That's actually the best casein terms of finishing early,at least in this recursive step.Because now the n over2 position is a peak.Because what you found isthat the n over 2 positionis greater than or equal toboth of its adjacent positions,and that's exactly thedefinition of a peak.So you're done.OK?So all of this is good.You want to write an argumentthat this algorithm is correct.And I'm not goingto bother with that.I just wave my hands abit, and you all nodded,so we're done with that.But the point being youwill see in your problem seta precise argument for a morecomplicated algorithm, the 2Dversion of this.And that should be a templatefor you to go write a proof,or an argument, aformal argument,that a particularalgorithm is correct.That it does whatit claims to do.And in this case it's two,three lines of careful reasoningthat essentially say, giventhe definition of the peak,that this is going tofind a peak in the arraythat you're given.All right?So we all believe thatthis algorithm is correct.Let's talk now about thecomplexity of this algorithm.Because the wholepoint of this algorithmwas because we didn'tlike this thetan complexity corresponding tothe straightforward algorithm.So it'd like to do better.So what I'd like todo is ask one of youto give me a recurrence relationof the kind, you know, T of nequals blah, blah, blah.That would correspond tothis recursive algorithm,this divide andconquer algorithm.And then using that, I'd liketo get to the actual complexityin terms of what the thetaof complexity corresponds to.Yeah?Back there?AUDIENCE: So the worstcase scenario if T of nis going to be someconstant amount of time--PROFESSOR: Yep.AUDIENCE: --it takes toinvestigate whether a certainelement is [INAUDIBLE], plus--[COUGH]--T of n over 2?PROFESSOR: Great.Exactly right.That's exactly right.So if you look at thisalgorithm and you say,from a computationstandpoint, can Iwrite an equationcorresponding to the executionof this algorithm?And you say, T of n is the workthat this algorithm does on--as input of size n.OK?Then I can write this equation.And this theta 1 correspondsto the two comparisonsthat you do looking at--potentially the two comparisonsthat you do-- lookingat the left handside and the right hand side.So that's-- 2 is a constant,so that's why we put theta 1.All right?So you get a cushion, too.Watch out guys.Whoa!Oh actually that wasn't so bad.Good.Veers left, Eric.Veers left.So if you take this andyou start expanding it,eventually you're goingto get to the basecase, which is Tof 1 is theta 1.Right?Because you have a one elementarray you just for that arrayit's just going toreturn that as a peak.And so if you do that, andyou expand it all the way out,then you can write T of nequals theta 1 plus theta 1.And you're going to do thislog to the base 2 of n times.And adding theseall up, gives youa complexity theta log 2 of n.Right?So now you comparethis with that.And there's reallya huge difference.There's an exponentialdifference.If you coded up thisalgorithm in Python--and I did-- both thesealgorithms for the 1D version--and if you run it on nbeing 10 million or so,then this algorithmtakes 13 seconds.OK?The-- The theta 10algorithm takes 13 seconds.And this one takes0.001 seconds.OK?Huge difference.So there is a big differencebetween theta n and theta logn.It's literally the differencebetween 2 raised to n, and n.It makes sense to tryand reduce complexityas you can see,especially if you'retalking about large inputs.All right?And you'll see thatmore clearly as wego to a 2D versionof this problem.All right?So you can't reallydo better for the 1D.The 1D is astraightforward problem.It gets a littlemore interesting--the problems get alittle-- excuse me,the algorithms get alittle more sophisticatedwhen we look at a 2Dversion of peak finding.So let's talk aboutthe 2D version.So as you can imaginein the 2D versionyou have a matrix, or atwo dimensional array.And we'll say this thinghas n rows and m columns.And now we have todefine what a peak is.And it's a hill.It's the obviousdefinition of a peak.So if you had a inhere, c, b, d, e.Then as you can guess, a isa 2D peak if, and only if,a greater than or equal to b;a greater than or equal to d, cand e.All right?So it's a little hill up there.All right?And again I've used thegreater than or equal to here,so that's similar tothe 1D in the casethat you'll always finda peak in any 2D matrix.Now again I'll give you thestraightforward algorithm,and we'll call it theGreedy Ascent algorithm.And the Greedy Ascent algorithmessentially picks a directionand, you know, tries tofollow that direction in orderto find a peak.So for example, if Ihad this particular----matrix; 14, 13,12, 15, 9, 11, 17--Then what might happen is ifI started at some arbitrarymidpoint-- So theGreedy Ascent algorithmhas to make choicesas to where to start.Just like we haddifferent cases here,you have to make a choiceas to where to start.You might want tostart in the middle,and you might want towork your way left first.Or you're going to all--You just keep going left,our keep going right.And if you hit anedge, you go down.So you make some choices asto what the default traversaldirections are.And so if you say youwant to start with 12,you are going to go lookfor something to left.And if it's greater than, you'regoing to follow that direction.If it's not, if it'sless, then you'regoing to go in the otherdirection, in this case,for example.So in this case you'll go to12, 13 , 14, 15, 16, 17, 19,and 20.And you'd find-- You'd find this peak.Now I haven't given youthe specific detailsof a Greedy Ascent algorithm.But I think if you look atthe worst case possibilitieshere, with respectto a given matrix,and for any givenstarting point,and for any given strategy-- interms of choosing left first,versus right first, or downfirst versus up first--you will have asituation where-- justlike we had in the 1Dcase-- you may end uptouching a large fraction ofthe elements in this 2D array.OK?So in this case, weended up, you know,touching a bunch ofdifferent elements.And it's quite possible thatyou could end up touching--starting from the midpoint--you could up touching halfthe elements, and in some cases,touching all the elements.So if you do a worst caseanalysis of this algorithm--a particular algorithm withparticular choices in termsof the starting point andthe direction of search--a Greedy Ascent algorithm wouldhave theta n m complexity.All right?And in the case where nequals m, or m equals n,you'd have theta nsquared complexity.OK?I won't spend verymuch time on this,because I want to talkto you about the divideand conquer versions of thisalgorithm for the 2D peak.But hopefully you'reall with me with respectto what the worstcase complexity is.All right?People buy that?Yeah.Question back there.AUDIENCE: Can you-- Isthat an approximation?Or can you actually getto n times m traversals?PROFESSOR: So there are specificGreedy Ascent algorithms,and specific matriceswhere, if I give youthe code for the algorithm, andI give you a specific matrix,that I could make you touchall of these elements.That's correct.So we're talkingabout worst case.You're being veryparanoid when youtalk about worstcase complexity.And so I'm-- handwaving a bit here,simply because I haven'tgiven you the specificsof the algorithm yet.Right?This is really aset of algorithms,because I haven'tgiven you the code,I haven't told youwhere it starts,and which direction it goes.But you go, dothat, fix it, and Iwould be the person who tries tofind the worst case complexity.Suddenly it's veryeasy to get to theta nm in terms of having someconstant multiplying n times m.But you can definitelyget to that constantbeing very close to 1.OK?If not 1.All right.So let's talk aboutdivide and conquer.And let's say thatI did somethinglike this, where I just triedto jam the binary searchalgorithm into the 2D version.All right?So what I'm going to do is----I'm going to pick the middlecolumn, j equals m over 2.And I'm going tofind a 1D peak usingwhatever algorithm I want.And I'll probably end up usingthe more efficient algorithm,the binary searchversion that's goneall the way to the leftof the board there.And let's say I find abinary peak at (i, j).Because I've picked a column,and I'm just finding a 1D peak.So this is j equals m over 2.That's i.Now I use (i,j).In particular row i as a start----to find a 1D peak on row i.And I stand up here,I'm really happy.OK?Because I say, wow.I picked a middle column,I found a 1D peak,that is theta m complexity tofind a 1D peak as we argued.And one side-- the theta m--AUDIENCE: Log n.PROFESSOR: Oh, I'm sorry.You're right.The log n complexity,that's what this was.So I do have that here.Yeah.Log n complexity.Thanks, Eric.And then once I do that, Ican find a 1D peak on row i.In this case rowi would be m wide,so it would be log m complexity.If n equals m, then I havea couple of steps of log n,and I'm done.All right?Am I done?No.Can someone tell mewhy I'm not done?Precisely?Yep.AUDIENCE: Because whenyou do the second partto find the peak inrow i, you might nothave that columnpeak-- There might notbe a peak on the column anymore.PROFESSOR: That'sexactly correct.So this algorithm is incorrect.OK?It doesn't work.It's efficient, but incorrect.OK?It's-- You want to be correct.You know being correctingand inefficientis definitely better thanbeing inefficient-- I'm sorry.Being incorrect and efficient.So this is anefficient algorithm,in the sense that it willonly take log n time,but it doesn't work.And I'll give youa simple examplehere where it doesn't work.The problem is----a 2D peak----may not exist----on row i.And here's an example of that.Actually this is-- This isexactly the example of that.Let's say that Istarted with this row.Since it's-- I'm startingwith the middle row,and I could start withthis one or that one.Let's say I startedwith that one.I end up finding a peak.And if this were 10 up here,I'd choose 12 as a peak.And it's quite possiblethat I return 12 as a peak.Even though 19 isbigger, because 12is a peak given10 and 11 up here.And then when I choosethis particular row,and I find a peak onthis row, it would be 14.That is a 1D peak on this row.But 14 is not a 2D peak.OK?So this particular example,14 would return 14.And 14 is not a 2D peak.All right?You can collect yourcushion after the class.So not so good.Look like an efficientalgorithm, but doesn't work.All right?So how can we get tosomething that actually works?So the last algorithm thatI'm going to show you--And you'll see four differentalgorithms in your problemset----that you'll have to analyzethe complexity for and decideif they're efficient,and if they're correct.But here's a-- arecursive versionthat is better than,in terms of complexity,than the GreedyAscent algorithm.And this one works.So what I'm going to dois pick a middle column.j equals m over 2 as before.I'm going to find theglobal maximum on column j.And that's goingto be at (i, j).I'm going to compare (i commaj minus 1), (i comma j),and (i,j plus 1).Which means that once I'vefound the maximum in this row,all I'm going to look tothe left and the right,and compare.I'm going to pickthe left columns.If (i comma j minus 1) isgreater than (i comma j)--and similarly for the right.And if in fact I-- eitherof these two conditionsdon't fire, and whatI have is (i comma j)is greater than or equalto (i comma j minus 1)and (i comma j plus1), then I'm done.Just like I hadfor the 1D version.If (i comma j) is greaterthan or equal to (i commaj minus 1), and (i comma jplus 1), that implies (i, j)is a 2D peak.OK?And the reason 